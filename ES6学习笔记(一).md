### let const 命令
1. let声明的变量拥有了块级作用域。
2. let必须先声明，才能使用，否则报错。
3. let在同一个作用域内不能重复声明同名变量。
4. const声明的变量值（普通类型）不能改变，常量。
5. const声明变量时候必须赋值。同时const也拥有let的特性。
### 变量的解构(deconstruct)赋值
略
### 函数的扩展
1. 函数参数可以设置默认值。
```javascript
function Point(x=0,y=0){
this.x=x;
this.y=y;
}
```
2. 非尾参数，在调用的时候，不可以省略（除非，传入undefined）。
3. 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
4. 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。
5. ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
6. 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
7. 函数的length属性，不包括 rest 参数。
8. ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
9. 函数的name属性，返回该函数的函数名。需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。
10. Function构造函数返回的函数实例，name属性的值为anonymous。
11. bind返回的函数，name属性值会加上bound前缀。
### 箭头函数
[我的博客](http://gruad.yancoder.com/2017/08/24/JS%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%BD%92%E7%BA%B3/)
### Promise对象
1. 是一种社区提出的一种异步解决方案。
2. Promise对象相当于一个容器，里面保存着未来才会结束的事件（通常是一个异步操作）的结果。
3. 从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。
4. 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
5. 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Fulfiled和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 Resolved（已定型）。
6. 如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
Promise缺点：
1. 首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。
2. 其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
3. 第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
So:
如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。
### 4. Generator函数
### 5. async函数
### 6. Class的基本用法和继承
### 7. 
